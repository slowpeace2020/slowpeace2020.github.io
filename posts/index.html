<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | slowpeace2020-blog</title>
<meta name=keywords content><meta name=description content="Posts - slowpeace2020-blog"><meta name=author content="Me"><link rel=canonical href=https://slowpeace2020.github.io/posts/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.5ff2630c4d1b3e25bc21f0ecd96681dbcf58219e741fa627857820b5485cb770.css integrity="sha256-X/JjDE0bPiW8IfDs2WaB289YIZ50H6YnhXggtUhct3A=" rel="preload stylesheet" as=style><link rel=icon href=https://slowpeace2020.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://slowpeace2020.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://slowpeace2020.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://slowpeace2020.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://slowpeace2020.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://slowpeace2020.github.io/posts/index.xml><link rel=alternate hreflang=en href=https://slowpeace2020.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Posts"><meta property="og:description" content="slowpeace2020-blog description"><meta property="og:type" content="website"><meta property="og:url" content="https://slowpeace2020.github.io/posts/"><meta property="og:image" content="https://slowpeace2020.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="slowpeace2020-blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://slowpeace2020.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Posts"><meta name=twitter:description content="slowpeace2020-blog description"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://slowpeace2020.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://slowpeace2020.github.io/ accesskey=h title="slowpeace2020-blog (Alt + H)"><img src=https://slowpeace2020.github.io/apple-touch-icon.png alt aria-label=logo height=35>slowpeace2020-blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://slowpeace2020.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://slowpeace2020.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://slowpeace2020.github.io/ title=slowpeace2020><span>slowpeace2020</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://slowpeace2020.github.io/>Home</a></div><h1>Posts
<a href=/posts/index.xml title=RSS aria-label=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Markdown Syntax Guide For L2</h2></header><div class=entry-content><p>This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.
...</p></div><footer class=entry-footer><span title='2019-03-11 00:00:00 +0000 UTC'>March 11, 2019</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;500 words&nbsp;·&nbsp;Hugo Authors</footer><a class=entry-link aria-label="post link to Markdown Syntax Guide For L2" href=https://slowpeace2020.github.io/posts/markdown-syntax.fr/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Markdown Syntax Guide For RTL</h2></header><div class=entry-content><p>This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.
...</p></div><footer class=entry-footer><span title='2019-03-11 00:00:00 +0000 UTC'>March 11, 2019</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;500 words&nbsp;·&nbsp;Hugo Authors</footer><a class=entry-link aria-label="post link to Markdown Syntax Guide For RTL" href=https://slowpeace2020.github.io/posts/markdown-syntax.fa/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>High_concurrent_distribute_system_design</h2></header><div class=entry-content><p>演进篇之分布式服务 假设系统的高峰期，10000/s请求量，DAU为几十万。现在做推广活动，冲击百万DAU，怎么优化系统支撑更高的并发流量呢？
当前系统的部署还是一体化架构，也就是说所有功能模块都被打包到一个大的web工程然后部署到服务器。
发现很多系统到一定阶段都会做微服务的拆分，那么究竟是什么促使我们将一体化架构拆分为微服务架构呢？是不是系统的整体QPS到达一两万就一定要做微服务拆分呢？
当初为什么选择单体架构？ 项目刚起步，想要尽快搭建起来，方便早点将产品投入市场，验证商业需求 开发简单直接，代码和项目集中管理； 维护简单，只有一个工程，节省运维的人力成本； 排查问题范围窄，目标性强； 发展到后期，功能越来越复杂，开发团队规模越来越大，缺陷显现：
技术层面上来说，数据库连接数成为系统瓶颈，数据库连接是比较重要的资源，连接过程耗时，而且MySQL连接的客户端数量有限，最多可以设置为16384，看起来很大，但是因为单体架构没有分层，服务器直接连接数据库，那么当前端请求量增加，服务器扩容，连接数也会增长。这些增长可能来自客户端的外网流量，还要部署单独的应用服务支撑其他部门的内网调用。 单体架构增加研发成本，当技术团队根据业务分成很多不同组，不同的小团队共同维护一套代码和系统时，沟通成本呈指数上升。一般一个小团队为5-7人，负责一部分功能模块的开发和维护。功能交叉重叠，重复开发，代码冲突极大增加，功能之间耦合严重，更改很小的逻辑导致整体功能回归测试错误，其他功能不可用，延长了交付时间。 系统运维困难，刚开始代码几千行，构建一次一分钟，可以很灵敏的频繁上线更新修复问题。但是当系统代码扩充到几十万，上完白，一次构建包括编译、测试、打包、上传到生产环境，花费时间达到十几分钟，任何小的修改都要构建整个项目，上线变更变得笨拙。 微服务怎么解决这些缺陷 按照业务做横向拆分 解决数据库层面的扩展性问题，原先尽管拆分了数据库，但是不同的模块都要查询某个数据库的数据，直接连接查询， 现在将这些查询业务需求独立拆分出来，无论外界需要什么数据，通通由这个拆分的服务提供
将与业务无关的公用服务抽取出来为单独的服务 将系统拆分之后，每一个服务功能内聚，维护人员职责明确，缩小测试范围，服务出现问题，也可以通过熔断、降级的方式减少对其他服务的影响。
微服务之后，怎么改造系统架构？ 可以参考《DDD 实战课》中，侧重讲解了微服务化拆分的具体过程
微服务拆分原则 服务内部功能要高内聚、低耦合，单一职责 服务拆分的粒度，前期粗略拆分，后期逐渐细化 拆分时尽量避免产品的日常迭代，一边做服务化拆分，一边做产品功能迭代。在现有单体架构的基础上不断剥离业务独立部署 剥离顺序：优先比较独立的边界服务，从非核心业务开始，有练习试错的机会；两个服务有依赖关系的时候，优先剥离被依赖的，比如内容服务依赖用户服务，先剥离用户服务再剥离内容服务 服务接口的定义具备可扩展性，比如服务接口的参数类型最好是封装类，增加参数的时候就不用修改接口的签名，只要在类中增加字段 微服务化带来的问题和解决思路 问题一，从同一进程的方法调用变成跨进程的网络调用，增加了接口响应时间 那么我们要选择高效的服务调用框架，接口调用方需要知道服务部署在哪些机器的哪些端口，这些信仰要存储在一个分布式一致性的存储中，此时我们要引入服务注册中心，用来管理各种服务的完整声明周期，包括存活状态检测
问题二，服务之间错综复杂的依赖关系 一个服务依赖多个其他服务，也会被多个服务依赖，如果这个服务出现性能问题，产生大量慢请求，就会导致这个服务的工作线程池的线程被占满，问题沿着依赖网络蔓延，直到整个系统故障，因此我们需要引入服务治理提醒，针对出现的问题，采用熔断、降级、限流、超时控制的方法，让问题限制在单一服务中，保证其他服务不受影响
问题三，调用链路长，请求响应超时或者错误，定位问题困难 请求调用链路涉及多个服务，出现问题不知道是哪个服务导致的，还有系统整体故障，外在表现是所有服务同一时间故障，无法确认源头 可以引入分布式追踪工具，关注单一慢请求的性能瓶颈 细致的服务端监控报表，关注依赖服务和资源的宏观性能表现
团队按照业务边界拆分6-8人，包括开发、测试、运维和DBA 团队人数不多，先做工程的拆分，把代码拆分到不同的子工程中，工程之间用jar做依赖，减少代码量和打包时间，子工程内部高内聚低耦合，减少研发成本
10 万 QPS 下如何实现毫秒级的服务调用？ 选择合适的网络模型，有针对性的调整网络参数，优化网络传输性能； 选择合适的序列化方式，提升封包、解包的性能；
RPC remote procedure call，封装了网络调用的细节，像调用本地服务一样调用远程服务。 常见的RPC框架有Dubbo, gRPC, Thrift。 java原生的远程过程调用框架叫RMI（Remote Method Invocation）。它让Java程序通过网络调用另一台机器上的Java对象的方法，是J2EE时代的EJB实现的基础。 另外一种实现是Web Service, 使用HTTP + SOAP（Simple Object Access Protocol）协议，保证跨语言，跨平台，只要支持Http协议，可以解析XML，就能使用Web service。但是XML封装数据，数据包体积大，性能比较差。
RPC调用步骤：
客户端将调用的类名、方法名、参数名、参数值等序列化为二进制流； 客户端将二进制流通过网络发送给服务端； 服务端接收二进制流，反序列化，得到类名、方法名、参数名、参数值等，通过动态代理的方式调用对应的方法得到返回值 服务端将返回值序列化，通过网络发送给客户端； 客户端对结果反序列化，得到调用的结果； 怎么提升网络传输性能 选择合适的IO模型 I/O请求分为等待资源的阶段，使用资源的阶段 等待的过程可以分为阻塞、非阻塞 使用的方式可以分为同步、异步...</p></div><footer class=entry-footer><span title='2024-06-16 08:57:30 -0400 EDT'>June 16, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;96 words&nbsp;·&nbsp;Slowpeace</footer><a class=entry-link aria-label="post link to High_concurrent_distribute_system_design" href=https://slowpeace2020.github.io/posts/high_concurrent_distribute_system_design_4/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>High_concurrent_distribute_system_design</h2></header><div class=entry-content><p>面试技巧 怎么介绍项目经历？ 简单说一下项目背景。比如你做了一个项目，项目的整体架构是一体化的还是服务化的？拆分成了哪些服务？服务之间是通过什么协议通信的？怎么交互的？使用了哪些开源组件？组件选型的时候考虑了哪些因素。
可以有意引导面试官到自己比较擅长的内容，比如你对Kafka、RocketMQ等消息队列有比较深入的了解，你可以说使用哪些消息队列解决了哪方面的问题，在其中遇到了哪些坑，又是怎么优化的。
在项目介绍中突出自己的贡献，不仅仅是项目本身的并发度，方案设计。
针对复杂的需求你设计了哪些方案，这些方案技术难点是什么？你怎么解决的？ 针对项目中的疑难杂症诡异的问题，你是怎么排查的？ 项目维护过程出现了哪些性能问题？你又是怎么优化的？ 参考案例一 这个案例涉及排查一次自研的 RPC 框架的故障，回答的思路如下：
项目中使用的 RPC 框架存在某个 Bug，偶发地出现 RPC 客户端发送给 RPC 服务节点的所有心跳包全部超时，从而让 RPC 客户端认为服务节点已经发生故障，然后 RPC 客户端就不会将流量发送给这个服务节点。由于项目中使用了 Nett3 框架，我就理了一遍 Netty3 的连接过程的代码，确认是 Boss 线程或者 NioWorke 线程某个地方阻塞了。
然后，我通过 strace（系统调用抓取工具）抓取那段时间的系统调用，发现 BosS 线程中涉及的系统调用全部完成了，却没有发现把 socket fd（文件句柄）注册给 NioWorker 的 selector（文件句柄）的系统调用，于是确认是 NioWorker 的问题。
后来我打印了 jvm thread stack trace （Java 的线程堆栈），发现所有的 NioWorker 线程阻塞在 Object.wait，代码位置是 Clas.for-Name，这样就导致所有的 NioWorker 不再处理新的 Register task（注册任务），Netty Client Bootstrap 中所有的 ConnectFuture 的状态自然不被标记，最终导致上层所有的连接超时。
再往下追查后，我发现 JDK6 中确实存在类初始化过程中出现死锁的 Bug，在升级到 JDK7 之后问题就得到解决。
你看，本来是一个偶发的 RPC 框架层的问题而你在追查这个 Bug 的过程中涉及到了 Netty 网络编程、系统调用追踪，和多线程锁诊断等知识，面试官在听到这样的案例之后，也会认可你排查问题的思路和能力。...</p></div><footer class=entry-footer><span title='2024-06-16 08:19:51 -0400 EDT'>June 16, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;168 words&nbsp;·&nbsp;Slowpeace</footer><a class=entry-link aria-label="post link to High_concurrent_distribute_system_design" href=https://slowpeace2020.github.io/posts/interview_skill/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>High_concurrent_distribute_system_design</h2></header><div class=entry-content><p>演进篇之消息队列 秒杀时如何处理每秒上万次的下单请求？ 异步处理、解耦合和削峰填谷 是消息队列在秒杀系统设计中起到的主要作用，其中，
异步处理可以简化业务流程中的步骤，提升系统性能； 削峰填谷可以削去到达秒杀系统的峰值流量，让业务逻辑的处理更加缓和； 解耦合可以将秒杀系统和数据系统解耦开，这样两个系统的任何变更都不会影响到另一个系统， 如果你的系统想要提升写入性能，实现系统的低耦合，想要抵挡高并发的写流量，那么你就可以考虑使用消息队列来完成。
消息投递：如何保证消息仅仅被消费一次？ 消息为什么会丢失 丢失的位置：生产者写入队列的过程中，消息存储在消息队列的时候，消息被消费者消费的过程中
怎么弥补？ a. 生产者写入队列的过程中： 消息重传，重试机制 b. 消息存储在消息队列的时候： kafka是先写入系统的Page Cache再定期写入硬盘，断电或者异常可能会丢失，频繁刷盘对性能有影响，可以考虑集群方式部署，多个副本备份数据 leader负责消息的写入和消费，多个follower负责备份数控，follower中的特殊集合叫ISR(in-sync replicas),acks=all的时候写入数据到leader和ISR才算成功，它们都挂了数据才会丢失，leader挂了就从ISR中选举 c. 消息被消费者消费的过程中: 接收消息、处理消息、更新消息进度都有可能异常或者失败，保证消息生产和消费的幂等性，执行多次和一次的结果一样， 生产过程中，kafka支持producer idempotency, 生产段重复产生，但消息队列只存储一份 消费段，从通用层和业务层保证幂等性，通过唯一ID校验，业务层可以加乐观锁，检查版本号，满足条件才执行操作
如何降低消息队列系统中消息的延迟？ 怎么监控消息延迟？ 一是使用消息队列提供的工具，监控消息的堆积情况： 首先要知道消费进度是多少，可以从zookeeper中获取，也有一个__consumer_offsets的topic，也有kafka-consumer-groups.sh的脚本也可以用JMX输出到监控系统，看版本情况
二是生成监控消息：
定义特殊消息（包含生成的时间戳，作为消费数据） 启动监控程序，把消息定时写入队列 业务程序消费到这个消息时就直接扔掉，监控程序消费到这个消息时就和这个消息的生成时间做笔记，看看时间差的情况 实际上时JMX（做dashboard）和第二种方式结合(报警阈值)
怎么减少消息延迟？ 消费端： 优化消费代码； 增加消费者数量；一个partition只能分给一个消费者，所以只能增加Partition，提升消费能力，或者在一个consumer中提升消息的并行度，多线程的方式增加处理能力，提高吞吐量。 注意消费线程空转的问题，会发生CPU占满的情况，消费端啦娶不到消息不间断轮询拉取，这个线程就把CPU占满了，控制轮询拉取间隔
消息队列本身 优化消息存储；刚开始用数据库存储消息，读取QPS只能到2000，重构存储模块，使用本地磁盘，Page Cache顺序读取，QPS提升了一个数量级 零拷贝技术； 原来是四次拷贝，磁盘–>内核缓冲区–>用户缓冲区–> Socket缓冲区–> 网卡缓冲区
操作系统用Sendfile函数，减少拷贝次数，省去了拷贝到用户缓冲区这一步，java中的java.nio.channels.FileChannel提供了transferTo的方法有类似功能
扩展 故障案例：前一段时间处理的一个故障，前期只是因为数据库性能衰减有少量的慢请求，结果这些慢请求占满了 Tomcat 线程池，导致整体服务的不可用。如果我们能对 Tomcat 线程池的任务堆积情况有实时地监控，或者说对线程池有一些保护策略，比方说线程全部使用之后丢弃请求，也许就会避免故障的发生。在此，我希望你在实际的工作中能够引以为戒，只要有队列就要监控它的堆积情况，把问题消灭在萌芽之中
消费中用线程池并行消费kafka的partition，有消息丢失的风险，这是为了性能需要容忍的消息丢失 生成监控消息的策略，一分钟生成一个监控消息，相对于业务每秒几十或者几百的消息，性能损坏微不足道</p></div><footer class=entry-footer><span title='2024-06-02 08:58:20 -0400 EDT'>June 2, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;58 words&nbsp;·&nbsp;Slowpeace</footer><a class=entry-link aria-label="post link to High_concurrent_distribute_system_design" href=https://slowpeace2020.github.io/posts/high_concurrent_distribute_system_design_3/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>High_concurrent_distribute_system_design</h2></header><div class=entry-content><p>演进篇之缓存 缓存定义 凡是位于速度相差较大的两种硬件之间，用于协调两者数据传输速度差异的结构，均可称之为缓存 。缓存作为一种常见的 空间换时间的性能优化手段。
我们熟知的 HTTP 协议也是有缓存机制的。**当我们第一次请求静态的资源时，比如一张图片，服务端除了返回图片信息，在响应头里面还有一个 Etag 的字段。浏览器会缓存图片信息以及这个字段的值。当下一次再请求这个图片的时候，浏览器发起的请求头里面会有一个 If-None-Match 的字段，并且把缓存的 Etag 的值写进去发给服务端。服务端比对图片信息是否有变化，如果没有，则返回浏览器一个 304 的状态码，浏览器会继续使用缓存的图片信息。通过这种缓存协商的方式，可以减少网络传输的数据大小，从而提升页面展示的性能。
缓冲区则是一块临时存储数据的区域，这些数据后面会被传输到其他设备上。 缓冲区更像「消息队列篇」中即将提到的消息队列，用以弥补高速设备和低速设备通信时的速度差 。
静态缓存、分布式缓存和热点本地缓存 静态缓存在 Web 1.0 时期是非常著名的，它一般通过生成 Velocity 模板或者静态 HTML 文件来实现静态缓存，在 Nginx 上部署静态缓存可以减少对于后台应用服务器的压力。
对于动态的请求你可以选择分布式缓存
什么时候要考虑热点本地缓存呢？
答案是当我们遇到极端的热点数据查询的时候。 热点本地缓存主要部署在应用服务器的代码中，用于阻挡热点查询对于分布式缓存节点或者数据库的压力。 我们会在代码中使用一些本地缓存方案，如 HashMap，Guava Cache 或者是 Ehcache 等，它们和应用程序部署在同一个进程中，优势是不需要跨网络调度，速度极快，所以可以来阻挡短时间内的热点查询。 由于本地缓存是部署在应用服务器中，而我们应用服务器通常会部署多台，当数据更新时，我们不能确定哪台服务器本地中了缓存，更新或者删除所有服务器的缓存不是一个好的选择，所以我们通常会等待缓存过期。因此，这种缓存的有效期很短，通常为分钟或者秒级别，以避免返回前端脏数据。
缓存的缺点 缓存比较适合于读多写少的业务场景，并且数据最好带有一定的热点属性。 缓存会给整体系统带来复杂度，并且会有数据不一致的风险。 缓存通常使用内存作为存储介质，但是内存并不是无限的。 缓存会给运维也带来一定的成本。
缓存可以有多层，静态缓存处在负载均衡层，分布式缓存处在应用层和数据库层之间，本地缓存处在应用层。我们需要将请求尽量挡在上层，因为越往下层，对于并发的承受能力越差； 缓存命中率是我们对于缓存最重要的一个监控项，越是热点的数据，缓存的命中率就越高。
如何选择缓存策略 Cache Aside 变更数据库和变更缓存是两个独立的操作，而我们并没有对操作做任何的并发控制。那么当两个线程并发更新它们的时候，就会因为写入顺序的不同造成数据的不一致。
那我们要如何解决这个问题呢？ 其实，我们可以在更新数据时不更新缓存，而是删除缓存中的数据，在读取数据时，发现缓存中没了数据之后，再从数据库中读取数据，更新到缓存中。
Cache Aside 策略（也叫旁路缓存策略），这个策略数据 以数据库中的数据为准，缓存中的数据是按需加载的 。它可以分为读策略和写策略，
读策略的步骤是：
从缓存中读取数据； 如果缓存命中，则直接返回数据； 如果缓存不命中，则从数据库中查询数据； 查询到数据后，将数据写入到缓存中，并且返回给用户。
写策略的步骤是：
更新数据库中的记录； 删除缓存记录。
像 Cache Aside 策略这样先更新数据库，后删除缓存就没有问题了吗？ 其实在理论上还是有缺陷的。假如某个用户数据在缓存中不存在，请求 A 读取数据时从数据库中查询到年龄为 20，在未写入缓存中时另一个请求 B 更新数据。它更新数据库中的年龄为 21，并且清空缓存。这时请求 A 把从数据库中读到的年龄为 20 的数据写入到缓存中，造成缓存和数据库数据不一致。...</p></div><footer class=entry-footer><span title='2024-05-23 09:41:46 -0400 EDT'>May 23, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;439 words&nbsp;·&nbsp;Slowpeace</footer><a class=entry-link aria-label="post link to High_concurrent_distribute_system_design" href=https://slowpeace2020.github.io/posts/high_concurrent_distribute_system_design_2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>High_concurrent_distribute_system_design</h2></header><div class=entry-content><p>演进篇之数据库 池化技术 刚开始数据库的调用方式是先获取数据库的连接，然后依靠这条连接从数据库中查询数据，最后关闭连接释放数据库资源。频繁地建立数据库连接耗费时间长导致了访问慢的问题。整个 MySQL 的连接过程大概消耗了 4ms，SQL 的平均执行时间大概是 1ms，也就是说相比于 SQL 的执行，MySQL 建立连接的过程是比较耗时的。按照原来的方式建立一次连接只执行一条 SQL 的话，1s 只能执行 200 次数据库的查询，而数据库建立连接的时间占了其中 4/5。 解决方案也很简单，只要使用连接池将数据库连接预先建立好，这样在使用的时候就不需要频繁地创建连接了。调整之后，你发现 1s 就可以执行 1000 次的数据库查询，查询性能大大的提升了。
数据库连接池有两个最重要的配置： 最小连接数和最大连接数 它们控制着从连接池中获取连接的流程：
如果当前连接数小于最小连接数，则创建新的连接处理数据库请求；
如果连接池中有空闲连接则复用空闲连接；
如果空闲池中没有可以用的连接并且当前连接数小于最大连接数，则创建新的连接处理请求；
如果当前连接数已经大于等于最大连接数，则按照配置中设定的时间（C3P0 的连接池配置是 checkoutTimeout）等待旧的连接可用；
如果等待超过了这个设定时间则向用户抛出错误。
连接池的维护问题 故障原因一：数据库的域名对应的 IP 发生了变更 故障原因二：wait_timeout参数，控制着当数据库连接闲置多长时间后，数据库会主动的关闭这条连接。这个机制对于数据库使用方是无感知的，所以当我们使用这个被关闭的连接时就会发生错误。
怎么维护？
启动一个线程来定期检测连接池中的连接是否可用，前 C3P0 连接池可以采用这种方式来检测连接是否可用。
在获取到连接之后，先校验连接是否可用，如果可用才会执行 SQL 语句。比如 DBCP 连接池的 testOnBorrow 配置项，就是控制是否开启这个验证。这种方式在获取连接时会引入多余的开销， 在线上系统中还是尽量不要开启，在测试服务上可以使用。
多线程并行处理与数据库之间的交互 用线程池预先创建线程 JDK 1.5 中引入的 ThreadPoolExecutor 就是一种线程池的实现，它有两个重要的参数：coreThreadCount 和 maxThreadCount，这两个参数控制着线程池的执行过程。
如果线程池中的线程数少于 coreThreadCount 时，处理新的任务时会创建新的线程；
如果线程数大于 coreThreadCount 则把任务丢到一个队列里面，由当前空闲的线程执行；
当队列中的任务堆积满了的时候，则继续创建线程，直到达到 maxThreadCount；
当线程数达到 maxTheadCount 时还有新的任务提交，那么我们就不得不将它们丢弃了
JDK 实现的这个线程池优先把任务放入队列暂存起来，而不是创建更多的线程 ，它比较适用于执行 CPU 密集型的任务，也就是需要执行大量 CPU 运算的任务。这是为什么呢？因为执行 CPU 密集型的任务时 CPU 比较繁忙，因此只需要创建和 CPU 核数相当的线程就好了，多了反而会造成线程上下文切换，降低任务执行效率。所以当当前线程数超过核心线程数时，线程池不会增加线程，而是放在队列里等待核心线程空闲下来。...</p></div><footer class=entry-footer><span title='2024-05-19 08:46:46 -0400 EDT'>May 19, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;549 words&nbsp;·&nbsp;Slowpeace</footer><a class=entry-link aria-label="post link to High_concurrent_distribute_system_design" href=https://slowpeace2020.github.io/posts/high_concurrent_distribute_system_design_1/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>High_concurrent_distribute_system_design</h2></header><div class=entry-content><p>面试现场 其实你无需对组件达到源代码级别的了解，只需要深入了解它的实现原理，再结合一些基础知识，如算法、网络、操作系统等等，就足够应对 80% 的面试问题。
在面试的过程中，当你被问到组件的实现原理时，面试官其实想要了解你，是否对于实现原理中涉及的基础知识有足够的了解？在实际开发中，你是否能够运用这些基础知识来设计合理的方案？以及，当这些组件发生问题的时候，你是否有思路解决？
经典面试题 HashMap 实现的底层数据结构是怎样的? 如果发生 Hash 冲突，要怎么解决？常见的解决方式是怎样的? JDK8 中对 Hash Map 做了什么样的优化呢？ 红黑树的实现原理是怎样的？相比于链表它的优势和劣势都是什么？ HashMap 是线程安全的吗？ ConcurrentHashMap 是如何做到线程安全的呢？ 传统关系型数据库的可扩展性是很差的，那么在你看来，世面上常见的 NoSQL 数据库是如何解决扩展性的问题呢？ 如果你是连接池的设计者你会怎么设计，有哪些关键点？ 在实际的项目中，你可能会用到其他的池化技术，你可以和我分享一下在研发过程中，还使用过哪些其它池化技术吗？又因池化技术踩过哪些坑，当时你是怎么解决的？ 比如一个流程要调用三四个服务，前两个调用成功了，第三个失败了。类似的这种情况，该怎么处理呢？ 你在实际的工作中可能已经使用过一些 RPC 框架，那么结合你的实际经验，可以和我说说在 RPC 框架使用过程中，遇到了哪些问题吗？又是如何排查和解决的呢？ 你大可以试着回答一下 ，看看自己对上面几个问题是一知半解呢？还是能全部回答上来呢？
你看，虽然面试官问的是 JDK 中一个类的实现原理，但这里面涉及了数组、链表、红黑树等基本的算法；解决Hash 冲突的基本思路； 并发线程安全的含义，以及解决线程不安全问题的基本思路，并且也可以引出和线程安全相关的一系列问题。
了解了这些基本原理,除了可以夯实你的基础知识以外，还可以为你的方案设计提供思路。比如说，当需要更高效的读写内存中的数据时可以怎么做，遇到并发问题时要如何来解决等等。
最后，也是最重要的，了解了组件的基本原理你在使用这些组件的时候才能够充分发挥它的优点、避免踩坑，在遇到问题的时候也会有排查的思路。
todo 我建议你阅读一下，成熟的 RPC 框架的源代码。比如，阿里开源的 Dubbo，微博的 Motan 等等，理解它们的实现原理和细节，这样你会更有信心维护好你的微服务系统；同时，你也可以从优秀的代码中，学习到代码设计的技巧，比如说 Dubbo 对于 RPC 的抽象，SPI 扩展点的设计，这样可以有助你提升代码能力。</p></div><footer class=entry-footer><span title='2024-05-19 08:36:12 -0400 EDT'>May 19, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;53 words&nbsp;·&nbsp;Slowpeace</footer><a class=entry-link aria-label="post link to High_concurrent_distribute_system_design" href=https://slowpeace2020.github.io/posts/interview_note/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Test</h2></header><div class=entry-content><p>title: “我的第一篇文章” date: 2024-05-10 author: “你的名字” 这是我的第一篇文章的内容。</p></div><footer class=entry-footer><span title='2024-05-09 15:36:31 -0400 EDT'>May 9, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;7 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Test" href=https://slowpeace2020.github.io/posts/test/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Everything is a project</h2></header><div class=entry-content><p>有目的、有计划、有步骤地解决问题的方法就是工程方法 站在整体而非局部去看问题
如果能站在项目整体来看问题，你就会去关注项目的质量、项目的进度、项目的成本、项目的最终用户，那么上面这些场景将变成：
为了项目整体的效率和避免返工浪费，产品经理会及早和开发人员确认技术可行性，并对产品设计先行验证； 为了节约项目开发成本，提高开发效率，架构师选择成熟的架构，合理购买商业组件和使用开源程序； 为了提升开发效率，不影响项目开发进度，开发工程师尽可能采用成熟的技术，高效简洁地落实项目； 为了项目质量和效率，测试工程师学习自动化测试技术，将大部分测试变成自动化运行，极大地提高了测试效率和质量； 为了让用户有好的体验，不仅产品经理，每个人都会仔细体验用户界面，对于不合理的地方提出改进意见。</p></div><footer class=entry-footer><span title='2024-03-14 00:00:00 +0000 UTC'>March 14, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;8 words&nbsp;·&nbsp;slowpeace2020</footer><a class=entry-link aria-label="post link to Everything is a project" href=https://slowpeace2020.github.io/posts/software_project_1/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://slowpeace2020.github.io/posts/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://slowpeace2020.github.io/>slowpeace2020-blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>